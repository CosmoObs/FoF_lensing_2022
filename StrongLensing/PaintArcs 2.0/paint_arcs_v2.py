#!/usr/bin/python
# =====================================================
# Authors:
# Cristina Furlanetto - furlanetto.cristina@gmail.com
# Eduardo Valad√£o - eduardovaladao98@gmail.com
# =====================================================

""" Module with the functions necessary to simulate the surface brightness of gravitational arcs, 
Einstein rings and Einstein crosses as in realistic astronomical images using the Point Lens, SIS, SIE, 
SIEP and NFW plus optional external shear and convergence models with elliptical source. This is a work in 
progress, so my apologies to the user if any errors arise and if my code is too ugly. """

##@module paint_arcs
#
# This module generates the pixelation of the lensed images created by a 
# Point Lens, SIS, SIE, SIEP or NFW plus optional external shear and convergence 
# deflecting the light rays of a distant elliptical source with a Sersic surface
# brightness radial profile. 
#
# It uses Sersic profiles as the radial light distribution of the elliptical source. 
# Its main objective is to mimic lensed images generated by the strong lensing effect 
# in the galaxy-galaxy scale. The SIS, SIE and SIEP models are used to describe dark 
# matter halos of galaxies in general, but in the case of elliptical galaxies these 
# physical models can describe very well the mass distribution of these cosmic objects. 
# Although, the Point Lens in this case is used to simulate hypothetical extragalactic 
# black holes lensing distant galaxies. 
# 
# The main goal of this code is that it allows the user to control all the input
# parameters of the simulated lensed images. But beyond that, the main advantage 
# of this module is the use of only analytical gravitational lensing models by 
# utilizing a somewhat new technique created by the second author.
#

import re
import sys
import os
import math
import imcp
import string 
import logging
import numpy as np
import mpmath as mp
import header_funcs
import config_parser as cp
import lensing_models as lm
import astropy.io.fits as pyfits
from get_sersic_b_n import get_sersic_b_n
from convert_arcsec_pix import convert_arcsec_pix

sys.path.append(os.path.abspath( '.' ))
cwd = os.getcwd()+'/'

ps_factor = 2.0

def sbmap_x_y(model, x1, x2, s1, s2, phie, e, f, k, u, theta_e, x1_0, x2_0, ks, n, b_n, r_e, I_0):
    ''' 
    Function to compute the value of the Sersic surface brightness of the
    (x,y) pixel following the user chosen model in lensing_models.py.

    Input:
    - model <func>: lens model in lensing_models.py
    - x1 <float>: x position (pixel)
    - x2 <float>: y position (pixel)
    - s1 <float>: x position of the point where the source is centered (pixel)
    - s2 <float>: y position of the point where the source is centered (pixel)
    - phie <float>: orientation of the elliptical source relative to the x-axis (radians)
    - e <float>: ellipticity of the source 
    - f <float>: ellipticity of the lens in the SIE model or ellipticity of the gravitational potential in the SIEP model
    - k <float>: external convergence 
    - u <float>: external shear 
    - theta_e <float>: angular einstein radius
    - x1_0 <float>: x position of the origin of coordinates (pixel) 
    - x2_0 <float>: y position of the origin of coordinates (pixel)
    - n <float>: index that describes the slope of the Sersic profile 
    - b_n <float>: coefficient of the Sersic profile that depends on the n index
        b_n is chosen so that half the total luminosity predicted by the Sersic profile comes from r <= r_e 
    - r_e <float>: radius that encloses half of the total luminosity of the Sersic profile (pixel)
    - I_0 <float>: central surface brightness of the Sersic profile 

    Output:
    - <float>: the value of the surface brightness of the (x,y) point following the user chosen model in lensing_models.py.
    '''
    radial_profile = lm.elliptical_radial_profile(model, x1, x2, s1, s2, phie, e, f, k, u, theta_e, x1_0, x2_0, ks)
    exp_arg = - b_n*(radial_profile/r_e)**(1.0/float(n)) 
    return I_0*math.exp(exp_arg)   


def create_sbmap(model, r0, s1, s2, phie, e, f, k, u, theta_e, x1_0, x2_0, ks, n, b_n, r_e, I_0, mag_zpt, pix_size):
    '''	
    Function to create the surface brightness map following the user chosen lens model with elliptical 
    source and digitalize ("pixelize") it to an image with the same size as the input image. 

    Input:
    - s1 <float>: x position of the point where the source is centered (pixel)
    - s2 <float>: y position of the point where the source is centered (pixel)
    - phie <float>: orientation of the elliptical source relative to the x-axis (radians)
    - e <float>: ellipticity of the source 
    - f <float>: ellipticity of the lens in the SIE model or ellipticity of the gravitational potential in the SIEP model
    - k <float>: external convergence 
    - u <float>: external shear 
    - theta_e <float>: angular einstein radius
    - x1_0 <float>: x position of the origin of coordinates (pixel) 
    - x2_0 <float>: y position of the origin of coordinates (pixel)
    - n <float>: index that describes the slope of the Sersic profile 
    - b_n <float>: coefficient of the Sersic profile that depends on the n index
        b_n is chosen so that half the total luminosity predicted by the Sersic profile comes from r <= r_e 
    - r_e <float>: radius that encloses half of the total luminosity of the Sersic profile (pixel)
    - I_0 <float>: central surface brightness of the Sersic profile
    - mag_zpt <float>: zero-point magnitude of the image
    - pix_size <float>: size of the "new" pixel for the digitalization

    Output:
    - (ndarray,s_total): resultant array of the digitalization of the surface brightness map and the
        value of the total signal distributed over the new array
    '''
    # Determining the size of the postage stamp, this is the size of the image. I usually take it to be twice
    # the einstein radius, but the user can choose any value:
    ps_size = int(ps_factor*(2*theta_e))  
    s = np.zeros((ps_size + 1, ps_size + 1))
    s_total = []
 
    m = int(1.0/pix_size)
    if m == 0:
        m = 1

    h = 1.0/m
    
    ps_xmin = int(x1_0 - ps_size/2.0)
    ps_xmax = int(x1_0 + ps_size/2.0)
    ps_ymin = int(x2_0 - ps_size/2.0)
    ps_ymax = int(x2_0 + ps_size/2.0)		

    x_new = -1

    for x in range(ps_xmin, ps_xmax):
        x_new = x_new + 1
        y_new = -1
        for y in range(ps_ymin, ps_ymax):	
            y_new = y_new + 1
            if (x - x1_0)**2 + (y - x2_0)**2 == 0:
                x_min = 10e-10
            else:
                x_min = x 
            if (x - x1_0)**2 + (y - x2_0)**2 == 0:
                y_min = 10e-10
            else:
                y_min = y 
            if sbmap_x_y(model, x_min, y_min, s1, s2, phie, e, f, k, u, theta_e, x1_0, x2_0, ks, n, b_n, r_e, I_0) >= I_0*math.exp(-b_n*(r0/r_e)**(1.0/float(n))):  
                s[y_new][x_new] = sum([sum([sbmap_x_y(model, x_min + i*h, y_min + j*h, s1, s2, phie, e, f, k, u, theta_e, x1_0, x2_0, ks, n, b_n, r_e, I_0) for j in range(0, m)]) for i in range(0, m)])/float(m)/float(m)
                s_total.append(s[y_new][x_new])	
            else:
                s[y_new][x_new]= 0.0
                s_total.append(s[y_new][x_new])
    s_sum = sum(s_total)
    return s,s_sum,ps_size


def paint_arcs(params, pix_scale):
    '''	
    Function to digitalize the arc surface brightness map and write it on a HDU.
    
    It computes the sbmap_x_y derivative to find the size of the "new" pixel for 
    digitalization. Then it calls the function create_sbmap to create the surface 
    brightness map and digitalize it. 
    
    This function returns the HDU resultant of the digitalization of the surface brightness map.
    The parameters of the arc are added to the HDU header. 

    Input:
    - params: list with all necessary parameters [r0, s1, s2, phie, n, r_e, e, mag, mag_zpt, 
    f, k, u, theta_e, x1_0, x2_0, model]
    
    Output:
    - hdu: resultant hdu of the digitalization of the surface brightness map 
    '''

    r0 = convert_arcsec_pix(float(params[0]), pix_scale)
    s1 = convert_arcsec_pix(float(params[1]), pix_scale)
    s2 = convert_arcsec_pix(float(params[2]), pix_scale) 
    phie = math.radians(float(params[3]))
    n = float(params[4])
    r_e = convert_arcsec_pix(float(params[5]), pix_scale)
    e = float(params[6])
    mag = float(params[7])
    mag_zpt = float(params[8])
    f = float(params[9])
    k = float(params[10])
    u = float(params[11])
    theta_e = convert_arcsec_pix(float(params[12]), pix_scale)
    x1_0 = convert_arcsec_pix(float(params[13]), pix_scale)
    x2_0 = convert_arcsec_pix(float(params[14]), pix_scale)
    ks = float(params[15])
    model = int(params[16])

    b_n = get_sersic_b_n(n)

    signal_total = 10.0**(-0.4*(mag - mag_zpt))

    theta0 = mp.atan2((s2 - x2_0), (s1 - x1_0))
    if (theta0 - phie) >= 0:
        phie1 = theta0 - phie
    elif (theta0 - phie) < 0 and abs(theta0 - phie) <= mp.pi:
        phie1 = abs(theta0 - phie) + mp.pi  
    elif (theta0 - phie) < 0 and abs(theta0 - phie) > mp.pi:
        phie1 = 2*mp.pi - abs(theta0 - phie)  

    if model == 2:
        # The code is not yet optimized, so it may take a while to run in the SIS case:
        I_0 = (signal_total)/(lm.I_0_integral_sis(r_e, n, b_n, s1, s2, phie1, e, theta_e, x1_0, x2_0, r0))
    else:
        # The user can choose any value here, for now only the SIS model has the calculation of I_0 based on
        # the astronomical magnitude of the image.
        I_0 = 45 
        
    epsilon = 0.1

    pix_size = lm.pixel_size_sis(epsilon, r_e, n, b_n, e, phie, s1, s2, x1_0, x2_0)

    sbmap,s_sum,ps_size = create_sbmap(model, r0, s1, s2, phie, e, f, k, u, theta_e, x1_0, x2_0, ks, n, b_n, r_e, I_0, mag_zpt, pix_size)
    
    error = abs(s_sum - signal_total)/signal_total 

    hdu = pyfits.PrimaryHDU(sbmap)

    hdr = hdu.header

    hdr['MODEL'] = ('SIS', 'Singular Isothermal Sphere')
    hdr['ERES'] = (params[0], 'Effective Radius of the Source (arcsec)')
    hdr['ES'] = (params[6], 'Ellipticity of the Source')
    hdr['AOES'] = (params[3], 'Angular Orientation of the Source (degrees)')
    hdr['XPCEC'] = (params[1], 'X Position of the Center of the Source (arcsec)')
    hdr['YPCEC'] = (params[2], 'Y Position of the Center of the Source (arcsec)')
    hdr['XPCI'] = (params[13], 'X Position of the Center of the Image (arcsec)')
    hdr['YPCI'] = (params[14], 'Y Position of the Center of the Image (arcsec)')
    hdr['NINDEX'] = (params[4], 'Arcs Sersic Profile index') 
    hdr['RE'] = (params[5], 'Arcs Sersic Effective Radius (arcsec)')
    hdr['IO'] = (float(I_0), 'Surface Brightness in the Center of the Source')
    hdr['SMAG'] = (mag, 'Arcs Magnitude')
    hdr['MAG_ZPT'] = (mag_zpt, 'Zero Point Magnitude') 
    hdr['ESM'] = (f , 'Ellipticity of the SIE or SIEP Model') 
    hdr['EC'] = (k, 'External Convergence')
    hdr['ES'] = (u, 'External Shear')
    hdr['ER'] = (params[12], 'Einstein Radius')
    hdr['NFWC'] = (ks, 'Navarro-Frenk-White convergence')
    
    hdr['ASIGDIST'] = (s_sum, 'Signal of the Arcs Distributed by PaintArcs')
    if model == 2:
        hdr['ASIG'] = (signal_total, 'Total Signal of the Arcs')
        hdr['FLUXERR'] = (error, 'Error on the Distributed Arcs Flux')

    return hdu
	
